;; This buffer is for notes you don't want to save, and for Lisp evaluation.
;; If you want to create a file, visit that file with C-x C-f,
;; then enter the text in that file's own buffer.

((vmState(i) = ready | vmState(i) = sleeping | vmState(i) = waiting) |
(vmState(j) = ready | vmState(j) = sleeping | vmState(j) = waiting)) |
((host(i) = node4i & host(j) = node4j) | (host(i) = node4j & host(j) = node4i))


->
((vmState(i) = ready | vmState(i) = sleeping | vmState(i) = waiting) |
(vmState(j) = ready | vmState(j) = sleeping | vmState(j) = waiting)) |
(host(i) = node4i & host(j) = node4j) |
(host(i) = node4j & host(j) = node4i)

or(or,or)

s(i) = r 
s(j) = r
h(i) = n4i & h(j) = n4j

P= vmState(i) = runing & vmState(j) = running --> host(i) /= host(j)
P= (vmState(i) /= running | vmState(j) /= running) | host(i) /= host(j)

-> states:
vmState(i) /= running
vmState(j) /= running
host(i) /= host(j)

-> Generate all the assignments
  -> expand sur chaque
     and(or..)
 
  ((vmState(i) = ready | vmState(i) = sleeping | vmState(i) = waiting) &
  (vmState(j) = ready | vmState(j) = sleeping | vmState(j) = waiting)) &
  (host(i) = node4i & host(j) = node4j) &
 (host(i) = node4j & host(j) = node4i)

  -> plein d'Ã©tat


  -> tagger les goods et les no-goods

/!\ no-good due to impossible unconsistencies (host(i) + waiting for example)

/*
Typing system
*/

Type:
  Element
  Set
  Pack

Primitives:
  nat
  VM
  node

  Type.domain()
  Type.subElementType()

  
Predefined variables:
VM : Set<VM>
node : Set<Node>
nat : Set<Integer>

Set.subElementType() : Element
Element.subElementType() : null

vs <: VM /* vs : Set */ -> domain(): ts les sous-ensembles possible de son parent