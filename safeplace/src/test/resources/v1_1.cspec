core constraint noVMsOnOfflineNodes() ::= !(n : nodes) nodeState(n) = offline --> card(hosted(n)) = 0
core constraint hostingRunningVMs() ::= !(v : vms) vmState(v) = running --> host(v) : nodes & nodeState(host(v)) = online
core constraint hostingSleepingVMs() ::= !(v : vms) vmState(v) = sleeping --> host(v) : nodes & nodeState(host(v)) = online
core constraint noHostForReadyVMs() ::= !(v : vms) vmState(v) = ready --> host(v) = none
core constraint noHostForTerminatedVMs() ::= !(v : vms) vmState(v) = terminated --> host(v) = none

discrete constraint offline(ns <: nodes) ::=
    !(n : ns) nodeState(n) = offline

discrete constraint online(ns <: nodes) ::=
    !(n : ns) nodeState(n) = online

discrete constraint running(vs <: vms) ::=
    !(v : vs) vmState(v) = running

discrete constraint ready(vs <: vms) ::=
    !(v : vs) vmState(v) = ready

discrete constraint sleeping(vs <: vms) ::=
    !(v : vs) vmState(v) = sleeping

discrete constraint killed(vs <: vms) ::=
    !(v : vs) vmState(v) = terminated

constraint among (vs <: vms, parts : packings(nodes))  ::=
    ?(g : parts) {host(i). i : vs, vmState(i) = running} <: g

constraint ban(vs <: vms, ns <: nodes) ::=
    !(v : vs) vmState(v) = running --> host(v) /: ns

constraint fence(vs <: vms, ns <: nodes) ::=
    !(v : vs) vmState(v) = running --> host(v) : ns

constraint cumulatedRunningCapacity(ns <: nodes, nb : int) ::=
    sum({card(running(n)). n : ns}) <= nb

constraint cumulatedResourceCapacity(ns <: nodes, id : string, qty: int) ::=
    sum({capa(i, id). i : ns}) <= qty

constraint gather(vs <: vms) ::=
    !(x,y : vs)  (x /= y & vmState(x) = running & vmState(y) = running) --> host(x) = host(y)

constraint lonely (vs <: vms) ::=
	!(i : vs) vmState(i) = running --> (colocated(i) - {i}) /<: vs

constraint maxOnline(ns <: nodes, nb : int) ::=
   	card({i. i : ns , nodeState(i) = online}) <= nb

constraint overbook(ns <: nodes, id : string, qty: float) ::=
    !(n : ns) sum({cons(v, id). v : running(n)}) * qty < capa(n, id)

constraint preserve(vs <: vms, id : string, qty: int) ::=
    !(v : vs) vmState(v) = running --> cons(v, id) <= qty

constraint root(vs <: vms) ::=
    !(v : vs) vmState(v) = running --> ^host(v) = host(v)

constraint quarantine(ns <: nodes) ::=
     !(n : ns) !(v : hosted(n)) root(v) & ban({hosted(n2). n2 /: ns})

constraint sequentialVMTransitions(sched : lists(vms)) ::=
    !(i,j : range(sched)) (i /= j & vmState(sched[i]) : {booting, suspending, resuming, halting}) -->
        (
        vmState(sched[j]) : {running, sleeping, ready, terminated} &
        ((j < i & vmState(sched[j]) /= vmState(sched[j])) | (j > i & vmState(sched[j]) = ^vmState(sched[j])))
        )

constraint singleRunningCapacity(ns <: nodes, nb : int) ::=
	!(n : ns) card(running(n)) <= nb

constraint spread(vs <: vms) ::=
     !(x,y : vs) (x /= y &  vmState(x) = running & vmState(y) = running) --> host(x) /= host(y)

constraint singleResourceCapacity(ns <: nodes, id : string, qty: int) ::=
    !(n : ns) nodeState(n) = online --> capa(n, id) <= qty

constraint split(part : packings(vms)) ::=
    { {host(v). v : p , vmState(v) = running}. p : part} : packings(nodes)

constraint splitAmong(vs : packings(vms), part : packings(nodes)) ::=
    !(p : part) among(vs, p) & split(vs)
