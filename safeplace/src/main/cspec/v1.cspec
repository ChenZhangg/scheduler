 /** The core constraints */
core constraint noVMsOnOfflineNodes() ::=
    !(n : nodes) nodeState(n) /= online --> card(hosted(n)) = 0

core constraint toRunning() ::=
    !(v : vms) vmState(v) = running --> ^vmState(v) : {ready, running, sleeping}

core constraint toReady() ::=
    !(v : vms) vmState(v) = ready --> ^vmState(v) : {ready, running}

core constraint toSleeping() ::=
    !(v : vms) vmState(v) = sleeping --> ^vmState(v) : {running, sleeping}

/** State constraints */
discrete constraint running(v : vms) ::=
    vmState(v) = running

discrete constraint ready(v : vms) ::=
    vmState(v) = ready

discrete constraint sleeping(v : vms) ::=
    vmState(v) = sleeping

discrete constraint offline(n : nodes) ::=
    nodeState(n) = offline

discrete constraint online(n : nodes) ::=
    nodeState(n) = online

discrete constraint killed(v : vms) ::=
    vmState(v) = terminated

/** VM-to-VM affinity */
constraint among (vs <: vms, parts : packings(nodes))  ::=
    ?(g : parts) {host(i). i : vs, vmState(i) = running} <: g

constraint gather(vs <: vms) ::=
    !(x,y : vs) (x /= y & vmState(x) = running & vmState(y) = running) --> host(x) = host(y)

constraint lonely (vs <: vms) ::=
	!(i : vs) vmState(i) = running --> (colocated(i) - {i}) <: vs

constraint spread(vs <: vms) ::=
     !(x,y : vs) (x /= y & vmState(x) = running & vmState(y) = running) --> host(x) /= host(y)

constraint split(part : packings(vms)) ::=
    { {host(v). v : p , vmState(v) = running}. p : part} : packings(nodes)

constraint splitAmong(vs : packings(vms), part : packings(nodes)) ::=
    (!(v : vs) among(v, part)) & split(vs)


/** VM-to-PM affinity */
constraint ban(v : vms, ns <: nodes) ::=
    vmState(v) = running --> host(v) /: ns

constraint fence(v : vms, ns <: nodes) ::=
    vmState(v) = running --> host(v) : ns

constraint root(v : vms) ::=
    vmState(v) = running --> ^host(v) = host(v)

constraint quarantine(n : nodes) ::=
     (!(v : hosted(n)) root(v)) & (!(v2 /: hosted(n)) ban(v2, {n}))

/** Counting **/
constraint runningCapacity(ns <: nodes, nb : int) ::=
    sum([card(running(n)). n : ns]) <= nb

constraint maxOnline(ns <: nodes, nb : int) ::=
   	card({i. i : ns , nodeState(i) = online}) <= nb


/** Resource */
constraint resourceCapacity(ns <: nodes, id : string, qty: int) ::=
    sum([capa(i, id). i : ns]) <= qty

constraint overbook(n : nodes, id : string, qty: float) ::=
    sum({cons(v, id). v : running(n)}) * qty < capa(n, id)

constraint preserve(v : vms, id : string, qty: int) ::=
    vmState(v) = running --> cons(v, id) <= qty

/** Misc. */
constraint sequentialVMTransitions(sched : lists(vms)) ::=
    !(i,j : range(sched)) (i /= j & vmState(sched[i]) : {booting, suspending, resuming, halting}) -->
        (
        vmState(sched[j]) : {running, sleeping, ready, terminated} &
        ((j < i & vmState(sched[j]) /= vmState(sched[j])) | (j > i & vmState(sched[j]) = ^vmState(sched[j])))
        )