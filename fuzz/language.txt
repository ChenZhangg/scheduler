VMS := set<vm> //all the VMs
NODES := set<node> //all the nodes
NATS := set<nat> //all the naturals
VM_STATE := {running, sleeping, waiting, terminated}
VM_STATE := {online, offline} 

/*Predefined functions:*/

host := vm -> node	
hosted := node -> vm
colocated := vm -> set<vm>
state := vm -> VM_STATE
state := node -> NODE_STATE
	
constraint spread(vs <: VMS) ::
/*V1*/	all(i,j : vs). state(i) = running && state(j) = running -> host(j) /= host(i) 
/*V2*/	all(i,j : vs[state = runing]). host(j) /= host(i) 	


constraint ban(vs <: VMS, ns <: NODES ) ::
/*V1*/ all(i : vs). state(i) = running -> host(i) /: ns
/*V2*/ all(i : vs). [state = runing]). host(i) /: ns
}

constraint fence(vs <: VMS, ns <: NODES ) {
/*V1*/	all(i : vs). state(i) = running -> host(i) : ns
/*V12/	all(i : vs[state = running]). host(i) : ns
}

constraint gather(vs <: VMS) {
/*V1*/	all(i, j : vs). state(i) = running && state(j) = running -> host(i) = host(j)
/*V2*/	all(i, j : vs[state = running]). host(i) = host(j)
}

constraint lonely(vs <: VMS) {
/* V1 */	all(i : vs). state(i) = running -> colocated(i) - {i} /:< vs
/* V2 */	all(i : vs[state = running]). colocated(i) - {i} /:< vs
}

constraint maxOnline(ns <: NODES, nb : NAT) {
/* V1 */	card({i | i : ns && state(i) = online}) <= nb 
/* V2 */	card(ns[state = online]) <= nb 
}

constraint quarantine(ns <: NODES) {
...
}

constraint root (v : vm) {
	state(v)  /= running || host(v) = next host(v)
}

constraint runningCapacity(ns <: NODES, nb : NAT) {
	all(n : ns). card(hosted(n)) <= nb
}

func cons(rc,vm) -> nat
func capa(rc,node) -> nat

constraint resourceCapacity(ns <: NODES, rc : RES, nb : NAT) {
	let on := hosted(ns)
	sum({cons(rc, i) |i : on}) <= nb		
}

constraint preserve(v : VMS, rc : RES, nb : NAT) {
	/* if state(v) = running */

	c := capa(rc, host(v))
	c >= sum({cons(rc, v2) | v,v2 : colocated(i) && v2 /= v}) + cons(rc, v)		
}

constraint among (vs <: VMS, groups <: P(NODES)) {	
/*V1 */	on := {host(i) | i : vs && state(i) = running}
		exists(on :< g) | g : groups

/* V2 */
		on := vs[state = running]
}

constraint split(groups <: P(VMS)) {

/*V1*/	{ {host(i) | i : g && state(i) = running} | g : groups} <: P(NODES)		
/*V2*/	{ {host(i) | g[state=runing]} | g : groups} <: P(NODES)		
}

constraint splitAmong(vgroups <: P(VMS), pgroups <: P(NODES)) {	
	(all(vgroup : group). among(vgroup, pgroups)) && split(vgroups)
}

constraint nodeState(n : NODES, st : NODE_STATE) {
	state(n) = st
}

constraint vmState(v : VMS, st : VM_STATE) {
	state(v) = st
}

/*
Question:
- Définition de fonctions ?
  -> prototype dans la spec ou tout dans l'implem
  -> comment on créé des types ?
  -> composition de contraintes ?
  -> opérateur pour définir qqch (variable | contrainte)

Et les contraintes natives ?
- pas de VMs sur les noeuds offline
- les VMs waiting sont hébergées sur la forge
- les VM running|sleeping sur 1 noeud
- les VM terminated sur aucun noeud
- un noeud online peut hébergé des VMs
*/
