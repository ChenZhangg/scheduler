Objectif:
 - Aider le dev à implanter des contraintes de placement
   -> error prone:
      + des good qui ne passent pas
      + des no-good qui passent
   -> comment vérifier que l'implem est correct ?
      + générer des tests unitaires depuis un invariant straighforward

Etape 1:
   Ecrire des invariants pour les contraintes


Etape 2:
   Produire des instances parcourant tous l'espace d'état de l'invariant

Etape 3:
   Modèle intermédiaire réductible pour aider le dev à voir les endroits
   oublié

Etape 4:
   Générer des instances pour différents gestionnaires de ressources

Generation de code:
  depuis l'invariant:
    -> générer la contrainte côté API
    -> générer la sérialisation de la contrainte ?
    -> générer le checker

spread(x :< VM) :=
 i,j : x
 state(i) == "running" && state(j) == "running" -> host(i) != host(j)

constraint ban(x :< VM, y :< Node) {
 i : x
 j : y
 all(i), all(j), state(i) == "running" -> host(i) != j
}

fence(x :< VM, y :< Node) :=
 i : x
 j : y
 state(i) == "running" -> host(i) = j
 
gather(x :< VM) :=
 i,j : x
 state(i) == "running" && state(j) == "running" -> host(i) == host(j)

lonely(x :< VM) :=
 i : x
 state(i) == "running" -> hosted(host(i)) /\ x = {i}

maxOnline(x :< Node, n : nat) :=
 card({x | x \in n, state(i) == "online"}) <= n
 
quarantine(x :< Node) :=
 y : hosted(x) //Initialement

among(x <: VM, y <: NodexNode) :=  //Représentation de partitions

splitAmong :=

overbook